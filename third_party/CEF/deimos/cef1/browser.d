module deimos.cef1.browser;

// Copyright (c) 2012 Marshall A. Greenblatt. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the name Chromium Embedded
// Framework nor the names of its contributors may be used to endorse
// or promote products derived from this software without specific prior
// written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//

// #ifndef CEF_INCLUDE_CAPI_CEF_BROWSER_CAPI_H_
// #pragma once

// #ifdef __cplusplus
extern(C) {
// #endif

import deimos.cef1.base;


///
// Structure used to represent a browser window. The functions of this structure
// may be called on any thread unless otherwise indicated in the comments.
///
struct cef_browser_t {
  ///
  // Base structure.
  ///
  cef_base_t base;

  ///
  // Call this function before destroying a contained browser window. This
  // function performs any internal cleanup that may be needed before the
  // browser window is destroyed.
  ///
  extern(System) void function(cef_browser_t* self) parent_window_will_close;

  ///
  // Closes this browser window.
  ///
  extern(System) void function(cef_browser_t* self) close_browser;

  ///
  // Returns true (1) if the browser can navigate backwards.
  ///
  extern(System) int function(cef_browser_t* self) can_go_back;

  ///
  // Navigate backwards.
  ///
  extern(System) void function(cef_browser_t* self) go_back;

  ///
  // Returns true (1) if the browser can navigate forwards.
  ///
  extern(System) int function(cef_browser_t* self) can_go_forward;

  ///
  // Navigate forwards.
  ///
  extern(System) void function(cef_browser_t* self) go_forward;

  ///
  // Reload the current page.
  ///
  extern(System) void function(cef_browser_t* self) reload;

  ///
  // Reload the current page ignoring any cached data.
  ///
  extern(System) void function(cef_browser_t* self) reload_ignore_cache;

  ///
  // Stop loading the page.
  ///
  extern(System) void function(cef_browser_t* self) stop_load;

  ///
  // Set focus for the browser window. If |enable| is true (1) focus will be set
  // to the window. Otherwise, focus will be removed.
  ///
  extern(System) void function(cef_browser_t* self, int enable) set_focus;

  ///
  // Retrieve the window handle for this browser.
  ///
  extern(System) cef_window_handle_t function(cef_browser_t* self) get_window_handle;

  ///
  // Retrieve the window handle of the browser that opened this browser. Will
  // return NULL for non-popup windows. This function can be used in combination
  // with custom handling of modal windows.
  ///
  extern(System) cef_window_handle_t function(cef_browser_t* self) get_opener_window_handle;

  ///
  // Returns true (1) if the window is a popup window.
  ///
  extern(System) int function(cef_browser_t* self) is_popup;

  // Returns true (1) if a document has been loaded in the browser.
  extern(System) int function(cef_browser_t* self) has_document;

  ///
  // Returns the client for this browser.
  ///
  extern(System) cef_client_t* function(cef_browser_t* self) get_client;

  ///
  // Returns the main (top-level) frame for the browser window.
  ///
  extern(System) cef_frame_t* function(cef_browser_t* self) get_main_frame;

  ///
  // Returns the focused frame for the browser window. This function should only
  // be called on the UI thread.
  ///
  extern(System) cef_frame_t* function(cef_browser_t* self) get_focused_frame;

  ///
  // Returns the frame with the specified name, or NULL if not found. This
  // function should only be called on the UI thread.
  ///
  extern(System) cef_frame_t* function(cef_browser_t* self, const(cef_string_t)* name) get_frame;

  ///
  // Returns the names of all existing frames. This function should only be
  // called on the UI thread.
  ///
  extern(System) void function(cef_browser_t* self, cef_string_list_t names) get_frame_names;

  ///
  // Search for |searchText|. |identifier| can be used to have multiple searches
  // running simultaniously. |forward| indicates whether to search forward or
  // backward within the page. |matchCase| indicates whether the search should
  // be case-sensitive. |findNext| indicates whether this is the first request
  // or a follow-up.
  ///
  extern(System) void function(cef_browser_t* self, int identifier, const(cef_string_t)* searchText, int forward, int matchCase, int findNext) find;

  ///
  // Cancel all searches that are currently going on.
  ///
  extern(System) void function(cef_browser_t* self, int clearSelection) stop_finding;

  ///
  // Get the current zoom level. The default zoom level is 0.0. This function
  // can only be called on the UI thread.
  ///
  extern(System) double function(cef_browser_t* self) get_zoom_level;

  ///
  // Change the zoom level to the specified value. Specify 0.0 to reset the zoom
  // level. The change will be applied asynchronously on the UI thread.
  ///
  extern(System) void function(cef_browser_t* self, double zoomLevel) set_zoom_level;

  ///
  // Clear the back/forward browsing history.
  ///
  extern(System) void function(cef_browser_t* self) clear_history;

  ///
  // Open developer tools in its own window.
  ///
  extern(System) void function(cef_browser_t* self) show_dev_tools;

  ///
  // Explicitly close the developer tools window if one exists for this browser
  // instance.
  ///
  extern(System) void function(cef_browser_t* self) close_dev_tools;

  ///
  // Returns true (1) if window rendering is disabled.
  ///
  extern(System) int function(cef_browser_t* self) is_window_rendering_disabled;

  ///
  // Get the size of the specified element. This function should only be called
  // on the UI thread.
  ///
  extern(System) int function(cef_browser_t* self, cef_paint_element_type_t type, int* width, int* height) get_size;

  ///
  // Set the size of the specified element. This function is only used when
  // window rendering is disabled.
  ///
  extern(System) void function(cef_browser_t* self, cef_paint_element_type_t type, int width, int height) set_size;

  ///
  // Returns true (1) if a popup is currently visible. This function should only
  // be called on the UI thread.
  ///
  extern(System) int function(cef_browser_t* self) is_popup_visible;

  ///
  // Hide the currently visible popup, if any.
  ///
  extern(System) void function(cef_browser_t* self) hide_popup;

  ///
  // Invalidate the |dirtyRect| region of the view. This function is only used
  // when window rendering is disabled and will result in a call to
  // HandlePaint().
  ///
  extern(System) void function(cef_browser_t* self, const(cef_rect_t)* dirtyRect) invalidate;

  ///
  // Get the raw image data contained in the specified element without
  // performing validation. The specified |width| and |height| dimensions must
  // match the current element size. On Windows |buffer| must be width*height*4
  // bytes in size and represents a BGRA image with an upper-left origin. This
  // function should only be called on the UI thread.
  ///
  extern(System) int function(cef_browser_t* self, cef_paint_element_type_t type, int width, int height, void* buffer) get_image;

  ///
  // Send a key event to the browser.
  ///
  extern(System) void function(cef_browser_t* self, cef_key_type_t type, const(cef_key_info_t)* keyInfo, int modifiers) send_key_event;

  ///
  // Send a mouse click event to the browser. The |x| and |y| coordinates are
  // relative to the upper-left corner of the view.
  ///
  extern(System) void function(cef_browser_t* self, int x, int y, cef_mouse_button_type_t type, int mouseUp, int clickCount) send_mouse_click_event;

  ///
  // Send a mouse move event to the browser. The |x| and |y| coordinates are
  // relative to the upper-left corner of the view.
  ///
  extern(System) void function(cef_browser_t* self, int x, int y, int mouseLeave) send_mouse_move_event;

  ///
  // Send a mouse wheel event to the browser. The |x| and |y| coordinates are
  // relative to the upper-left corner of the view. The |deltaX| and |deltaY|
  // values represent the movement delta in the X and Y directions respectively.
  ///
  extern(System) void function(cef_browser_t* self, int x, int y, int deltaX, int deltaY) send_mouse_wheel_event;

  ///
  // Send a focus event to the browser.
  ///
  extern(System) void function(cef_browser_t* self, int setFocus) send_focus_event;

  ///
  // Send a capture lost event to the browser.
  ///
  extern(System) void function(cef_browser_t* self) send_capture_lost_event;
}


///
// Create a new browser window using the window parameters specified by
// |windowInfo|. All values will be copied internally and the actual window will
// be created on the UI thread. This function call will not block.
///
int cef_browser_create(cef_window_info_t* windowInfo, cef_client_t* client, const(cef_string_t)* url, const(cef_browser_settings_t)* settings);

///
// Create a new browser window using the window parameters specified by
// |windowInfo|. This function should only be called on the UI thread.
///
cef_browser_t* cef_browser_create_sync(cef_window_info_t* windowInfo, cef_client_t* client, const(cef_string_t)* url, const(cef_browser_settings_t)* settings);


// #ifdef __cplusplus
}
// #endif

// #endif CEF_INCLUDE_CAPI_CEF_BROWSER_CAPI_H_

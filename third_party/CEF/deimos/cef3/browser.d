module deimos.cef3.browser;

// Copyright (c) 2012 Marshall A. Greenblatt. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the name Chromium Embedded
// Framework nor the names of its contributors may be used to endorse
// or promote products derived from this software without specific prior
// written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// ---------------------------------------------------------------------------
//
// This file was generated by the CEF translator tool and should not edited
// by hand. See the translator.README.txt file in the tools directory for
// more information.
//

extern(C) {
    import deimos.cef3.base;
    import deimos.cef3.frame;
    import deimos.cef3.process_message;
    import deimos.cef3.request_context;
    import deimos.cef3.client;

    ///
    // Structure used to represent a browser window. When used in the browser
    // process the functions of this structure may be called on any thread unless
    // otherwise indicated in the comments. When used in the render process the
    // functions of this structure may only be called on the main thread.
    ///
    struct cef_browser_t {
        ///
        // Base structure.
        ///
        cef_base_t base;

        ///
        // Returns the browser host object. This function can only be called in the
        // browser process.
        ///
        extern(System) cef_browser_host_t* function(cef_browser_t* self) get_host;

        ///
        // Returns true (1) if the browser can navigate backwards.
        ///
        extern(System) int function(cef_browser_t* self) can_go_back;

        ///
        // Navigate backwards.
        ///
        extern(System) void function(cef_browser_t* self) go_back;

        ///
        // Returns true (1) if the browser can navigate forwards.
        ///
        extern(System) int function(cef_browser_t* self) can_go_forward;

        ///
        // Navigate forwards.
        ///
        extern(System) void function(cef_browser_t* self) go_forward;

        ///
        // Returns true (1) if the browser is currently loading.
        ///
        extern(System) int function(cef_browser_t* self) is_loading;

        ///
        // Reload the current page.
        ///
        extern(System) void function(cef_browser_t* self) reload;

        ///
        // Reload the current page ignoring any cached data.
        ///
        extern(System) void function(cef_browser_t* self) reload_ignore_cache;

        ///
        // Stop loading the page.
        ///
        extern(System) void function(cef_browser_t* self) stop_load;

        ///
        // Returns the globally unique identifier for this browser.
        ///
        extern(System) int function(cef_browser_t* self) get_identifier;

        ///
        // Returns true (1) if this object is pointing to the same handle as |that|
        // object.
        ///
        extern(System) int function(cef_browser_t *self, cef_browser_t *that) is_same;

        ///
        // Returns true (1) if the window is a popup window.
        ///
        extern(System) int function(cef_browser_t* self) is_popup;

        ///
        // Returns true (1) if a document has been loaded in the browser.
        ///
        extern(System) int function(cef_browser_t* self) has_document;

        ///
        // Returns the main (top-level) frame for the browser window.
        ///
        extern(System) cef_frame_t* function(cef_browser_t* self) get_main_frame;

        ///
        // Returns the focused frame for the browser window.
        ///
        extern(System) cef_frame_t* function(cef_browser_t* self) get_focused_frame;

        ///
        // Returns the frame with the specified identifier, or NULL if not found.
        ///
        extern(System) cef_frame_t* function(cef_browser_t* self, int64 identifier) get_frame_byident;

        ///
        // Returns the frame with the specified name, or NULL if not found.
        ///
        extern(System) cef_frame_t* function(cef_browser_t* self, const(cef_string_t)* name) get_frame;

        ///
        // Returns the number of frames that currently exist.
        ///
        extern(System) size_t function(cef_browser_t* self) get_frame_count;

        ///
        // Returns the identifiers of all existing frames.
        ///
        extern(System) void function(cef_browser_t* self, size_t* identifiersCount, int64* identifiers) get_frame_identifiers;

        ///
        // Returns the names of all existing frames.
        ///
        extern(System) void function(cef_browser_t* self, cef_string_list_t names) get_frame_names;

        //
        // Send a message to the specified |target_process|. Returns true (1) if the
        // message was sent successfully.
        ///
        extern(System) int function(cef_browser_t* self, cef_process_id_t target_process,
                                    cef_process_message_t* message) send_process_message;
    }


    ///
    // Callback structure for cef_browser_host_t::RunFileDialog. The functions of
    // this structure will be called on the browser process UI thread.
    ///
    struct cef_run_file_dialog_callback_t {
        ///
        // Base structure.
        ///
        cef_base_t base;

        ///
        // Called asynchronously after the file dialog is dismissed. If the selection
        // was successful |file_paths| will be a single value or a list of values
        // depending on the dialog mode. If the selection was cancelled |file_paths|
        // will be NULL.
        ///
        extern(System) void function(cef_run_file_dialog_callback_t* self, cef_browser_host_t* browser_host,
                                    cef_string_list_t file_paths) cont;
    }


    ///
    // Structure used to represent the browser process aspects of a browser window.
    // The functions of this structure can only be called in the browser process.
    // They may be called on any thread in that process unless otherwise indicated
    // in the comments.
    ///
    struct cef_browser_host_t {
        ///
        // Base structure.
        ///
        cef_base_t base;

        ///
        // Returns the hosted browser object.
        ///
        extern(System) cef_browser_t* function(cef_browser_host_t* self) get_browser;

        ///
        // Request that the browser close. The JavaScript 'onbeforeunload' event will
        // be fired. If |force_close| is false (0) the event handler, if any, will be
        // allowed to prompt the user and the user can optionally cancel the close. If
        // |force_close| is true (1) the prompt will not be displayed and the close
        // will proceed. Results in a call to cef_life_span_handler_t::do_close() if
        // the event handler allows the close or if |force_close| is true (1). See
        // cef_life_span_handler_t::do_close() documentation for additional usage
        // information.
        ///
        extern(System) void  function(cef_browser_host_t* self, int force_close) close_browser;

        ///
        // Set focus for the browser window. If |enable| is true (1) focus will be set
        // to the window. Otherwise, focus will be removed.
        ///
        extern(System) void function(cef_browser_host_t* self, int enable) set_focus;

        ///
        // Retrieve the window handle for this browser.
        ///
        extern(System) cef_window_handle_t function(cef_browser_host_t* self) get_window_handle;

        ///
        // Retrieve the window handle of the browser that opened this browser. Will
        // return NULL for non-popup windows. This function can be used in combination
        // with custom handling of modal windows.
        ///
        extern(System) cef_window_handle_t function(cef_browser_host_t* self) get_opener_window_handle;

        ///
        // Returns the client for this browser.
        ///
        extern(System) cef_client_t* function(cef_browser_host_t* self) get_client;

        ///
        // Returns the request context for this browser.
        ///
        extern(System) cef_request_context_t* function(cef_browser_host_t* self) get_request_context;

        ///
        // Get the current zoom level. The default zoom level is 0.0. This function
        // can only be called on the UI thread.
        ///
        extern(System) double function(cef_browser_host_t* self) get_zoom_level;

        ///
        // Change the zoom level to the specified value. Specify 0.0 to reset the zoom
        // level. If called on the UI thread the change will be applied immediately.
        // Otherwise, the change will be applied asynchronously on the UI thread.
        ///
        extern(System) void function(cef_browser_host_t* self, double zoomLevel) set_zoom_level;

        ///
        // Call to run a file chooser dialog. Only a single file chooser dialog may be
        // pending at any given time. |mode| represents the type of dialog to display.
        // |title| to the title to be used for the dialog and may be NULL to show the
        // default title ("Open" or "Save" depending on the mode). |default_file_name|
        // is the default file name to select in the dialog. |accept_types| is a list
        // of valid lower-cased MIME types or file extensions specified in an input
        // element and is used to restrict selectable files to such types. |callback|
        // will be executed after the dialog is dismissed or immediately if another
        // dialog is already pending. The dialog will be initiated asynchronously on
        // the UI thread.
        ///
        extern(System) void function(cef_browser_host_t* self, cef_file_dialog_mode_t mode,
                                    const(cef_string_t)* title, const(cef_string_t)* default_file_name,
                                    cef_string_list_t accept_types, cef_run_file_dialog_callback_t* callback)
                                        run_file_dialog;

        ///
        // Download the file at |url| using cef_download_handler_t.
        ///
        extern(System) void function(cef_browser_host_t* self, cef_string_t* url) start_download;

        ///
        // Print the current browser contents.
        ///
        extern(System) void function(cef_browser_host_t* self) print;

        ///
        // Search for |searchText|. |identifier| can be used to have multiple searches
        // running simultaniously. |forward| indicates whether to search forward or
        // backward within the page. |matchCase| indicates whether the search should
        // be case-sensitive. |findNext| indicates whether this is the first request
        // or a follow-up.
        ///
        extern(System) void function(cef_browser_host_t* self, int identifier, const(cef_string_t)* searchText,
                                    int forward, int matchCase, int findNext) find;

        ///
        // Cancel all searches that are currently going on.
        ///        
        extern(System) void function(cef_browser_host_t* self, int clearSelection) stop_finding;

        ///
        // Open developer tools in its own window.
        ///
        extern(System) void function(cef_browser_host_t* self, const(cef_window_info_t)* windowInfo,
                                    cef_client_t* client, const(cef_browser_settings_t)* settings) show_dev_tools;

        ///
        // Explicitly close the developer tools window if one exists for this browser
        // instance.
        ///
        extern(System) void function(cef_browser_host_t* self) close_dev_tools;

        ///
        // Set whether mouse cursor change is disabled.
        ///
        extern(System) void function(cef_browser_host_t* self, int disabled) set_mouse_cursor_change_disabled;

        ///
        // Returns true (1) if mouse cursor change is disabled.
        ///
        extern(System) int function(cef_browser_host_t* self) is_mouse_cursor_change_disabled;

        ///
        // Returns true (1) if window rendering is disabled.
        ///
        extern(System) int function(cef_browser_host_t* self) is_window_rendering_disabled;

        ///
        // Notify the browser that the widget has been resized. The browser will first
        // call cef_render_handler_t::GetViewRect to get the new size and then call
        // cef_render_handler_t::OnPaint asynchronously with the updated regions. This
        // function is only used when window rendering is disabled.
        ///
        extern(System) void function(cef_browser_host_t* self) was_resized;

        ///
        // Notify the browser that it has been hidden or shown. Layouting and
        // cef_render_handler_t::OnPaint notification will stop when the browser is
        // hidden. This function is only used when window rendering is disabled.
        ///
        extern(System) void function(cef_browser_host_t* self, int hidden) was_hidden;

        ///
        // Send a notification to the browser that the screen info has changed. The
        // browser will then call cef_render_handler_t::GetScreenInfo to update the
        // screen information with the new values. This simulates moving the webview
        // window from one display to another, or changing the properties of the
        // current display. This function is only used when window rendering is
        // disabled.
        ///
        extern(System) void function(cef_browser_host_t* self) notify_screen_info_changed;

        ///
        // Invalidate the |dirtyRect| region of the view. The browser will call
        // cef_render_handler_t::OnPaint asynchronously with the updated regions. This
        // function is only used when window rendering is disabled.
        ///
        extern(System) void function(cef_browser_host_t* self, const(cef_rect_t)* dirtyRect, cef_paint_element_type_t type) invalidate;

        ///
        // Send a key event to the browser.
        ///
        extern(System) void function(cef_browser_host_t* self, const(cef_key_event_t)* event) send_key_event;

        ///
        // Send a mouse click event to the browser. The |x| and |y| coordinates are
        // relative to the upper-left corner of the view.
        ///
        extern(System) void function(cef_browser_host_t* self, const(cef_mouse_event_t)* event, 
                                    cef_mouse_button_type_t type, int mouseUp, int clickCount) send_mouse_click_event;

        ///
        // Send a mouse move event to the browser. The |x| and |y| coordinates are
        // relative to the upper-left corner of the view.
        ///
        extern(System) void function(cef_browser_host_t* self, const(cef_mouse_event_t)* event, int mouseLeave) send_mouse_move_event;

        ///
        // Send a mouse wheel event to the browser. The |x| and |y| coordinates are
        // relative to the upper-left corner of the view. The |deltaX| and |deltaY|
        // values represent the movement delta in the X and Y directions respectively.
        // In order to scroll inside select popups with window rendering disabled
        // cef_render_handler_t::GetScreenPoint should be implemented properly.
        ///
        extern(System) void function(cef_browser_host_t* self, const(cef_mouse_event_t)* event, 
                                    int deltaX, int deltaY) send_mouse_wheel_event;

        ///
        // Send a focus event to the browser.
        ///
        extern(System) void function(cef_browser_host_t* self, int setFocus) send_focus_event;

        ///
        // Send a capture lost event to the browser.
        ///
        extern(System) void function(cef_browser_host_t* self) send_capture_lost_event;

        ///
        // Get the NSTextInputContext implementation for enabling IME on Mac when
        // window rendering is disabled.
        ///
        extern(System) void * function(cef_browser_host_t* self) get_nstext_input_context;

        ///
        // Handles a keyDown event prior to passing it through the NSTextInputClient
        // machinery.
        ///
        extern(System) void function(cef_browser_host_t* self, cef_event_handle_t* keyEvent) handle_key_event_before_text_input_client;

        ///
        // Performs any additional actions after NSTextInputClient handles the event.
        ///
        extern(System) void function(cef_browser_host_t* self, cef_event_handle_t* keyEvent) handle_key_event_after_text_input_client;
    }


    ///
    // Create a new browser window using the window parameters specified by
    // |windowInfo|. All values will be copied internally and the actual window will
    // be created on the UI thread. If |request_context| is NULL the global request
    // context will be used. This function can be called on any browser process
    // thread and will not block.
    ///
    int cef_browser_host_create_browser(
        const(cef_window_info_t)* windowInfo, cef_client_t *client,
        const(cef_string_t)* url, const(cef_browser_settings_t)* settings,
        cef_request_context_t* request_context);

    ///
    // Create a new browser window using the window parameters specified by
    // |windowInfo|. If |request_context| is NULL the global request context will be
    // used. This function can only be called on the browser process UI thread.
    ///
    cef_browser_t* cef_browser_host_create_browser_sync(
        const(cef_window_info_t)* windowInfo, cef_client_t* client,
        const(cef_string_t)* url, const(cef_browser_settings_t)* settings,
        cef_request_context_t* request_context);
}